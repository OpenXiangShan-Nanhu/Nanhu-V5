/***************************************************************************************
* Copyright (c) 2020-2021 Institute of Computing Technology, Chinese Academy of Sciences
* Copyright (c) 2020-2021 Peng Cheng Laboratory
*
* XiangShan is licensed under Mulan PSL v2.
* You can use this software according to the terms and conditions of the Mulan PSL v2.
* You may obtain a copy of Mulan PSL v2 at:
*          http://license.coscl.org.cn/MulanPSL2
*
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
* EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
* MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
*
* See the Mulan PSL v2 for more details.
***************************************************************************************/
package xiangshan.mem

import chisel3._
import chisel3.util._
import org.chipsalliance.cde.config._
import xiangshan._
import xiangshan.backend.rob.{RobPtr, RobLsqIO}
import xiangshan.ExceptionNO._
import xiangshan.cache._
import utils._
import xs.utils._
import xs.utils.perf._
import xiangshan.backend.Bundles
import xiangshan.backend.Bundles.{DynInst, MemExuOutput}
import xiangshan.backend.fu.FuConfig.LduCfg

class UncacheBufferEntrySimple(implicit p: Parameters) extends XSModule
  with HasCircularQueuePtrHelper
  with HasLoadHelper
{
  val io = IO(new Bundle() {

    // client requests
    val req = Flipped(Decoupled(new LqWriteBundle))

    // writeback mmio data
    val ldout = DecoupledIO(new MemExuOutput)
    val ld_raw_data = Output(new LoadDataFromLQBundle)

    // uncache io
    val uncache = new UncacheWordIO

    // exception generated by outer bus
    val exception = Valid(new LqWriteBundle)
    val error = Output(Bool())

    //for debug
    val entryInfo = new Bundle {
      val mmioEntry = ValidIO(new LqWriteBundle)
    }
  })

  val req_valid = RegInit(false.B)
  val req = Reg(new LqWriteBundle)

  val s_idle :: s_req :: s_resp :: s_wait :: Nil = Enum(4)
  val uncacheState = RegInit(s_idle)
  val uncacheData = Reg(io.uncache.resp.bits.data.cloneType)
  val nderr = RegInit(false.B)

  io.req.ready := !req_valid

  // enqueue
  when (io.req.valid) {
    XSError(req_valid, p"UncacheBuffer: You can not write an valid entry")
    req_valid := true.B
    req := io.req.bits
    nderr := false.B
  } .elsewhen (io.ldout.fire) {
    req_valid := false.B
  }

  switch (uncacheState) {
    is (s_idle) {
      when (req_valid) {
        uncacheState := s_req
      }
    }
    is (s_req) {
      when (io.uncache.req.fire) {
        uncacheState := s_resp
      }
    }
    is (s_resp) {
      when (io.uncache.resp.fire) {
        uncacheState := s_wait
      }
    }
    is (s_wait) {
      when (io.ldout.fire) {
        uncacheState := s_idle // ready for next mmio
      }
    }
  }
  io.uncache.req.valid     := uncacheState === s_req
  io.uncache.req.bits      := DontCare
  io.uncache.req.bits.cmd  := MemoryOpConstants.M_XRD
  io.uncache.req.bits.data := DontCare
  io.uncache.req.bits.addr := req.paddr
  io.uncache.req.bits.mask := Mux(req.paddr(3), req.mask(15, 8), req.mask(7, 0))
  io.uncache.req.bits.id   := 0.U
  io.uncache.req.bits.instrtype := DontCare
  io.uncache.req.bits.replayCarry := DontCare
  io.uncache.req.bits.device := req.device
  io.uncache.req.bits.nc := req.nc

  io.uncache.resp.ready := true.B

  when (io.uncache.req.fire) {
    XSDebug("uncache req: pc %x addr %x data %x op %x mask %x\n",
      req.uop.pc,
      io.uncache.req.bits.addr,
      io.uncache.req.bits.data,
      io.uncache.req.bits.cmd,
      io.uncache.req.bits.mask
    )
  }

  // (3) response from uncache channel
  when (io.uncache.resp.fire) {
    uncacheData := io.uncache.resp.bits.data
    nderr := io.uncache.resp.bits.nderr
  }.otherwise {
    nderr := false.B
  }

  // uncache writeback
  val selUop = req.uop
  val func = selUop.fuOpType
  val raddr = req.paddr
  val rdataSel = LookupTree(raddr(2, 0), List(
      "b000".U -> uncacheData(63,  0),
      "b001".U -> uncacheData(63,  8),
      "b010".U -> uncacheData(63, 16),
      "b011".U -> uncacheData(63, 24),
      "b100".U -> uncacheData(63, 32),
      "b101".U -> uncacheData(63, 40),
      "b110".U -> uncacheData(63, 48),
      "b111".U -> uncacheData(63, 56)
    ))
  val rdataPartialLoad = rdataHelper(selUop, rdataSel)

  io.ldout.valid              := (uncacheState === s_wait)
  io.ldout.bits               := DontCare
  io.ldout.bits.uop           := selUop
  io.ldout.bits.uop.lqIdx     := req.uop.lqIdx
  io.ldout.bits.data          := rdataPartialLoad
  io.ldout.bits.debug.isMMIO  := req.device
  io.ldout.bits.debug.paddr   := req.paddr
  io.ldout.bits.debug.vaddr   := req.vaddr

  io.ld_raw_data.lqData     := uncacheData
  io.ld_raw_data.uop        := req.uop
  io.ld_raw_data.addrOffset := req.paddr

  io.exception.valid := io.ldout.fire
  io.exception.bits := req
  io.exception.bits.fullva := SignExt(req.vaddr, XLEN)

  io.error := nderr

  when (io.ldout.fire) {
    req_valid := false.B

    XSInfo("int load miss write to cbd robidx %d lqidx %d pc 0x%x mmio %x\n",
      io.ldout.bits.uop.robIdx.asUInt,
      io.ldout.bits.uop.lqIdx.asUInt,
      io.ldout.bits.uop.pc,
      true.B
    )
  }

  io.entryInfo.mmioEntry.valid := req_valid
  io.entryInfo.mmioEntry.bits := req
}
